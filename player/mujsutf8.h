/*
 * This file wraps all mujs APIs which take or return strings and makes them
 * fully UTF-8. Simply include it after mujs.h and you're good.
 *
 * For mujs APIs which take or return strings, e.g. some js_foo, this file
 * defines the variants u_js_foo and c_js_foo, where the c_ variant is a direct
 * wrapper of js_foo, and the u_ variant exposes a UTF-8 API which converts
 * inputs from UTF-8 to CESU-8 (if required), and converts return values from
 * CESU-8 to UTF-8 (if required).
 *
 * It then defines js_foo as u_js_foo such that the normal names become UTF-8
 * APIs, while the CESU-8 API is still available via the c_ variant if needed.
 *
 *
 * Bugs:
 *
 * - js_loadfile and js_ploadfile currently (mujs 1.0.6) assume the source file
 *   on disk is CESU-8. This is a mujs bug and U8J does not try to fix it.
 *   It's recommended to read the file into memory and use u_js_[p]loadstring
 *   which do convert the source string to CESU-8 like mujs expects it to be.
 *
 *
 * Notes:
 *
 * U8J is stateless and does not store values such as callbacks for later use.
 * The best it could have done is use the rgistry, but that's not good enough
 * as U8J could need the value during js_freestate after it's been finalized.
 * Additionally, accessing the registry has a non-trivial performance cost.
 *
 * Specifically, the custom allocator at js_newstate, if one is provided, is
 * not used by U8J, and callbacks like js_HasProperty and js_Report are not
 * wrapped automaticallty to have their inputs as UTF-8.
 *
 * - To use a custom allocator the user should define an implementation for the
 *   function u8j_alloc. See more details at the comment for U8J_ALLOC_USER.
 *
 * - To get UTF-8 inputs in a callback the user should wrap the callback with
 *   one provided by U8J. See more details below.
 *
 *
 * Strings which are not converted:
 *
 * - reference names and typeof values don't need conversion. Both would be
 *   considered opaque anyway because they're generated by mujs.
 *
 * - registry names and filename arguments (like at u_js_loadstring) are not
 *   accessible as JS strings and are not converted. filename might end up as
 *   part of an error string, but then it's likely to be used as UTF-8 anyway,
 *   e.g. with u_js_getproperty(J, "stackTrace") or if reported to js_Report.
 *
 * - userdata tags and `error' sentinels (like at js_trystring(J, idx, error))
 *   are considered opaque and not converted. Note that userdata tags might end
 *   up as part of a JS string ("[object <tag>]"), so it's recommended to use
 *   tags which don't need conversion, or manage the conversion yourself.
 */

#ifndef U8J_NO_INCLUDE
    #include <stdlib.h>  /* size_t, realloc */
    #include <stdio.h>   /* vsnprintf at js_[name]error(J, fmt, ...) */
    #include <stdarg.h>  /* js_[name]error(J, fmt, ...) */
#endif


#define U8J_VERSION_MAJOR 1
#define U8J_VERSION_MINOR 0


/* define mujs.h macros if needed in case mujs.h changes in the future */

#ifndef JS_NORETURN
    /* copied verbatim from mujs.h version 1.0.6 */

    /* noreturn is a GCC extension */
    #ifdef __GNUC__
    #define JS_NORETURN __attribute__((noreturn))
    #else
    #ifdef _MSC_VER
    #define JS_NORETURN __declspec(noreturn)
    #else
    #define JS_NORETURN
    #endif
    #endif
#endif

#ifndef JS_PRINTFLIKE
    /* copied verbatim from mujs.h version 1.0.6 */

    /* GCC can do type checking of printf strings */
    #ifdef __printflike
    #define JS_PRINTFLIKE __printflike
    #else
    #if __GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ >= 7
    #define JS_PRINTFLIKE(fmtarg, firstvararg) \
        __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
    #else
    #define JS_PRINTFLIKE(fmtarg, firstvararg)
    #endif
    #endif
#endif


#ifdef __GNUC__
    #define U8J__UNUSED __attribute__ ((unused))
#else
    #define U8J_UNUSED
#endif

#define U8J_API U8J__UNUSED static


/*
 * lengths/sizes should be size_t, but mujs APIs use only int, and so do we for
 * compatibility, but make it obvious where size_t should have been used.
 * size_t is still used by U8J if it doesn't necessarily end up at mujs APIs.
 */
typedef int U8J_SIZ;

/* stack buffer size - avoid allocation if converting and it fits this size */
#ifndef U8J_IMPL_STACK_BUF_SIZ
    #define U8J_IMPL_STACK_BUF_SIZ 256
#endif


/*
#define U8J__DBG(...) \
    do { fprintf(stderr, __VA_ARGS__); fflush(stderr); } while(0)
*/


/**************************************************
 * CESU-8 and UTF-8 test and conversion functions *
 **************************************************/

/*
 * Unicode supplementary codepoint is U+10000 or higher. In UTF-8 it's a 4-bytes
 * sequence and in CESU-8 it's 6 (pair of 3-bytes surrogates). Other codepoints
 * are encoded as identical sequences in UTF-8 and CESU-8.
 *
 * CP >= U+10000 in UTF-8: 11110ccc 10ccbbbb 10bbbbaa 10aaaaaa
 * The top 5 bits (ccccc) must be non-zero and equal-to-or-less-than 0x10
 *
 * CP >= U+10000 in CESU-8: 11101101 1010yyyy 10bbbbbb 11101101 1011bbaa 10aaaaaa
 * the CP lower 16 bits are bb...aa, the top 5 are yyyy + 1
 */


/* tests up to 6 bytes, aborts crrectly on string termination */
static inline int u8j__is_cesu8_smp(const unsigned char *s)
{
    return s[0] == 0xed && (s[1] & 0xf0) == 0xa0 && (s[2] & 0xc0) == 0x80 &&
           s[3] == 0xed && (s[4] & 0xf0) == 0xb0 && (s[5] & 0xc0) == 0x80;
}

/* conversion can be in-place if src and dst are the same (utf8 is shorter) */
U8J_API void u8j_write_utf8(const char *cesu8_src, char *utf8_dst)
{
    const unsigned char *s = (const unsigned char *)cesu8_src;
    unsigned char *dst = (unsigned char *)utf8_dst;
    unsigned char top5;

    while (*s) {
        if (u8j__is_cesu8_smp(s)) {
            top5 = (s[1] & 0x0f) + 1;

            dst[0] = 0xf0 | top5 >> 2;
            dst[1] = 0x80 | (top5 & 0x03) << 4 | (s[2] & 0x3f) >> 2;
            dst[2] = 0x80 | (s[2] & 0x03) << 4 | (s[4] & 0x0f);
            dst[3] = s[5];

            s += 6;
            dst += 4;

        } else {
            *dst++ = *s++;
        }
    }

    *dst = 0;
}

/* 0 if no conversion to UTF-8 is required, else the expected UTF-8 strlen */
U8J_API size_t u8j_utf8_len(const char *cesu8)
{
    size_t i = 0, smp_count = 0;
    if (!cesu8)
        return 0;  /* no conversion required */

    for (; cesu8[i]; i++) {
        if (u8j__is_cesu8_smp((const unsigned char *)cesu8 + i))
            smp_count++;
    }

    return smp_count ? i - smp_count * 2 : 0;
}


/* tests up to 4 bytes, aborts crrectly on string termination */
static inline int u8j__is_utf8_smp(const unsigned char *s)
{
    return (s[0] & 0xf8) == 0xf0 &&
           (s[1] & 0xc0) == 0x80 && (s[2] & 0xc0) == 0x80 && (s[3] & 0xc0) == 0x80 &&
           !(s[0] & 0x04) != !((s[0] & 0x03) | (s[1] & 0x30)) /* top5: 0x01..0x10 */;
}

/*
 * writes cesu8_len+1 bytes to cesu8_dst (adds '\0').
 * cesu8_len must not be 0, and must come from js_[l]cesu8_len(..)
 */
U8J_API void u8j_write_cesu8(const char *utf8_src, char *cesu8_dst, size_t cesu8_len)
{
    const unsigned char *s = (const unsigned char *)utf8_src;
    unsigned char *dst = (unsigned char *)cesu8_dst;
    unsigned char * const fin = dst + cesu8_len;
    unsigned char top5;

    while (dst <= fin - 6) {
        if (u8j__is_utf8_smp(s)) {
            top5 = (s[0] & 0x07) << 2 | (s[1] & 0x30) >> 4;

            dst[0] = 0xed;
            dst[1] = 0xa0 | (top5 - 1);
            dst[2] = 0x80 | (s[1] & 0x0f) << 2 | (s[2] & 0x30) >> 4;

            dst[3] = 0xed;
            dst[4] = 0xb0 | (s[2] & 0x0f);
            dst[5] = s[3];

            s += 4;
            dst += 6;

        } else {
            *dst++ = *s++;
        }
    }
    while (dst < fin)
        *dst++ = *s++;

    *dst = 0;
}

/* 1 if no conversion to CESU-8 is required, else 0 */
U8J_API int u8j_same_as_cesu8(const char * const utf8)
{
    if (utf8) {
        for (int i = 0; utf8[i]; i++) {
            if (u8j__is_utf8_smp((const unsigned char *)utf8 + i))
                return 0;
        }
    }
    return 1;
}

/* 0 if no conversion to CESU-8 is required, else the expected CESU-8 strlen */
U8J_API size_t u8j_cesu8_len(const char * const utf8)
{
    size_t i = 0, smp_count = 0;
    if (!utf8)
        return 0;

    for (; utf8[i]; i++) {
        if (u8j__is_utf8_smp((const unsigned char *)utf8 + i))
            smp_count++;
    }

    /* currently we don't check if the addition wraps-around */
    return smp_count ? i + smp_count * 2 : 0;
}

U8J_API size_t u8j_lcesu8_len(const char *utf8, size_t const utf8_len)
{
    size_t i = 0, smp_count = 0;
    /* we allow NULL utf8 if utf8_len implies an actual buffer */
    if (utf8_len < 4)
        return 0;

    for (; i <= utf8_len - 4; i++) {
        if (u8j__is_utf8_smp((const unsigned char *)utf8 + i))
            smp_count++;
    }

    return smp_count ? utf8_len + smp_count * 2 : 0;
}


/**********************************************************************
 * u8j__malloc, u8j__free, and their setup possibly via u_js_newstate *
 **********************************************************************/


/* always uses plain realloc, ignoring alloc/actx at js_newstate */
#define U8J_ALLOC_PLAIN 0

/*
 * The user should implement `u8j_alloc' for this declaration:
 *     U8J_API void * u8j_alloc(js_State *J, void *ptr, U8J_SIZ size);
 *
 * This function should use ptr/size exactly like the alloc function at
 * js_newstate does.
 *
 * You'd probably want to store The actual alloc/actx values at the context,
 * set it with js_setcontext before any of the U8J wrappers are used, and then
 * u8j_alloc would grab them using js_getcontext.
 *
 * u8j_alloc is not called called during js_newstate nor js_setcontext, and may
 * be called during js_freestate but only while js_getcontext(J) still returns
 * the set context. In may also be called from U8J wrappers and/or during GC.
 */
#define U8J_ALLOC_USER 1


#ifndef U8J_IMPL_ALLOC
    #define U8J_IMPL_ALLOC U8J_ALLOC_PLAIN
#endif


U8J_API void *u8j_alloc(js_State *J, void *ptr, U8J_SIZ siz);

#if U8J_IMPL_ALLOC == U8J_ALLOC_PLAIN
    /* we provide the definition if the user doesn't */
    U8J_API void *u8j_alloc(js_State *J /* ignored */, void *ptr, U8J_SIZ siz) {
        return realloc(ptr, (size_t)siz);
    }
#endif

static void *u8j__malloc(js_State *J, U8J_SIZ siz) {
    void *ptr = u8j_alloc(J, NULL, siz);
    if (!ptr) {
        js_report(J, "U8J OOM");
        js_pushliteral(J, "U8J OOM");
        js_throw(J);
    }
    return ptr;
}

/* has the same prototype as js_Finalizer, can and is used as such */
static void u8j__free(js_State *J, void *ptr) {
    u8j_alloc(J, ptr, 0);
}


/* pushstring variants */

/* util: convert utf8 to cesu8 with known result length and push it */
static void u8j__pushslcesu8string(js_State *J, const char *utf8, int cesu8_len) {
    char buf[U8J_IMPL_STACK_BUF_SIZ];
    if (cesu8_len < sizeof buf) {
        u8j_write_cesu8(utf8, buf, cesu8_len);
        js_pushlstring(J, buf, cesu8_len);
        return;
    }

    char * volatile mem = u8j__malloc(J, cesu8_len + 1);
    u8j_write_cesu8(utf8, mem, cesu8_len);

    if (js_try(J)) {
        u8j__free(J, mem);
        js_throw(J);
    }
    js_pushlstring(J, mem, cesu8_len);
    js_endtry(J);

    u8j__free(J, mem);
}

U8J_API void c_js_pushlstring(js_State *J, const char *v, int n) { js_pushlstring(J, v, n); }
U8J_API void u_js_pushlstring(js_State *J, const char *v, int n) {
    U8J_SIZ cesu8_len = u8j_lcesu8_len(v, n);
    if (cesu8_len == 0)
        js_pushlstring(J, v, n);
    else
        u8j__pushslcesu8string(J, v, cesu8_len);
}

/* U8J__IN_NON could have been used, but here we reuse u8j__pushslcesu8string */
U8J_API void c_js_pushstring(js_State *J, const char *v) { js_pushstring(J, v); }
U8J_API void u_js_pushstring(js_State *J, const char *v) {
    if (u8j_same_as_cesu8(v))
        js_pushstring(J, v);
    else
        u8j__pushslcesu8string(J, v, u8j_cesu8_len(v));
}

U8J_API void c_js_pushliteral(js_State *J, const char *v) { js_pushliteral(J, v); }
U8J_API void u_js_pushliteral(js_State *J, const char *v) {
    /* mujs literals are cesu8. we define that so are ours, else as string */
    if (u8j_same_as_cesu8(v))
        js_pushliteral(J, v);
    else
        u8j__pushslcesu8string(J, v, u8j_cesu8_len(v));
}


/* UTF-8 return value userdata handling, and u_js_tostring which uses it */

static void u8j__utf8ret_selfValua(js_State *J)
{
    /* if we're ever used as JS string (unlikely), push a valid CESU-8 string */
    u_js_pushstring(J, (const char *)js_touserdata(J, 0, "u8j_ret"));
}

static int u8j__utf8ret_has(js_State *J, void *p, const char *name)
{
    /* this object supports only these two methods with 0 arguments */
    if (strcmp(name, "toString") && strcmp(name, "valueOf"))
        return 0;

    /*
     * maybe could be optimized by storing the instanciated c function at the
     * registry (once for all future utf8 userdata objects), and fetch it from
     * there on any subsequent use - inserting a c function could be expensive.
     * However, we provide these methods for compliance and interoperability
     * but don't really expect this to get used, ever, so KISS for now.
     */
    js_newcfunction(J, u8j__utf8ret_selfValua, "selfValue", 0);
    return 1;
}


/* push a VM-managed userdata which holds the resulting alloced UTF-8 value */
static const char *u8j__push_utf8ret(js_State *J, const char *cesu8, U8J_SIZ utf8_len)
{
    char * volatile mem = u8j__malloc(J, utf8_len + 1);
    u8j_write_utf8(cesu8, mem);

    if (js_try(J)) {
        u8j__free(J, mem);
        js_throw(J);
    }
    js_pushnull(J);  /* prototype of our object */
    js_newuserdatax(J, "u8j_ret", mem, u8j__utf8ret_has, NULL, NULL, u8j__free);
    js_endtry(J);

    return mem;  /* the VM will manage it from here using the u8j__free dtor */
}

U8J_API const char *c_js_tostring(js_State *J, int idx) { return js_tostring(J, idx); } \
U8J_API const char *u_js_tostring(js_State *J, int idx) {
    const char *str = js_tostring(J, idx);
    U8J_SIZ utf8_len = u8j_utf8_len(str);
    if (utf8_len == 0)
        return str;

    /* replace idx with a utf8 userdata and return the utf8 pointer */
    str = u8j__push_utf8ret(J, str, utf8_len);
    js_replace(J, idx < 0 ? idx - 1 : idx);
    return str;
}


/***************************************************
 * Wrappers for mujs APIs which take input strings *
 ***************************************************/

/*
 * Direct c_ variant wrapper and plain u_ UTF8 input wrappers:
 *   if no conversion is required - just invoke the cesu8 function,
 *   else if possible convert into a buffer and invoke, else convert into
 *   allocated space, try-invoke the cesu8 func, free the space.
 */

/* base body of a conversion wrapper - always converts */
#define U8J__IN_BODY_CONVERT(str_var, wrapped_call) \
    U8J_SIZ cesu8_len = u8j_cesu8_len(str_var); \
    if (cesu8_len < U8J_IMPL_STACK_BUF_SIZ) { \
        char buf[U8J_IMPL_STACK_BUF_SIZ]; \
        u8j_write_cesu8(str_var, buf, cesu8_len); \
        str_var = buf; \
        wrapped_call; \
    } else { \
        char * volatile mem = u8j__malloc(J, cesu8_len + 1); \
        u8j_write_cesu8(str_var, mem, cesu8_len); \
        str_var = mem; \
        if (js_try(J)) { \
            u8j__free(J, mem); \
            js_throw(J); \
        } \
        wrapped_call; \
        js_endtry(J); \
        u8j__free(J, mem); \
    }


#define U8J__IN_NON(name, proto_args, str_var, call_args) \
    static void u8j__cesu8_ ## name proto_args { \
        U8J__IN_BODY_CONVERT(str_var, js_ ## name call_args) \
    } \
    U8J_API void c_js_ ## name proto_args { js_ ## name call_args; } \
    U8J_API void u_js_ ## name proto_args { \
        if (u8j_same_as_cesu8(str_var)) \
            js_ ## name call_args; \
        else \
            u8j__cesu8_ ## name call_args; \
    }

#define U8J__IN_INT(name, proto_args, str_var, call_args) \
    static int u8j__cesu8_ ## name proto_args { \
        int ret_val; \
        U8J__IN_BODY_CONVERT(str_var, ret_val = js_ ## name call_args) \
        return ret_val; \
    } \
    U8J_API int c_js_ ## name proto_args { return js_ ## name call_args; } \
    U8J_API int u_js_ ## name proto_args { \
        if (u8j_same_as_cesu8(str_var)) \
            return js_ ## name call_args; \
        else \
            return u8j__cesu8_ ## name call_args; \
    }


/* [p]loadstring: source is converted, filename is not */
U8J__IN_INT(dostring, (js_State *J, const char *source), source, (J, source))
U8J__IN_NON(loadstring, (js_State *J, const char *filename, const char *source), source, (J, filename, source))
U8J__IN_INT(ploadstring, (js_State *J, const char *filename, const char *source), source, (J, filename, source))

U8J__IN_NON(getglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(setglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(delglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(defglobal, (js_State *J, const char *name, int atts), name, (J, name, atts))

U8J__IN_INT(hasproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(getproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(setproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(defproperty, (js_State *J, int idx, const char *name, int atts), name, (J, idx, name, atts))

U8J__IN_NON(delproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(defaccessor, (js_State *J, int idx, const char *name, int atts), name, (J, idx, name, atts))

U8J__IN_NON(newcfunction, (js_State *J, js_CFunction fun, const char *name, int length), name, (J, fun, name, length))
U8J__IN_NON(newcconstructor, (js_State *J, js_CFunction fun, js_CFunction con, const char *name, int length), name, (J, fun, con, name, length))
U8J__IN_NON(newregexp, (js_State *J, const char *pattern, int flags), pattern, (J, pattern, flags))

U8J__IN_NON(newstring, (js_State *J, const char *v), v, (J, v))


#undef U8J__IN_NON
#undef U8J__IN_INT


/* js_{c,u}_[new]<name>error */

#define U8J__DERROR(name_err) \
    U8J_API void c_js_new ## name_err(js_State *J, const char *s) { \
        js_new ## name_err(J, s); \
    } \
    U8J_API void u_js_new ## name_err(js_State *J, const char *s) { \
        /* a bit slower than U8J__IN_NON but less code. errors blow anyway */ \
        u_js_pushliteral(J, s); /* push as CESU-8 if conversion is needed */ \
        js_new ## name_err(J, /* c_ */ js_tostring(J, -1)); \
        js_replace(J, -2); \
    } \
    /* we can't have a tiny c_ wrapper with va_list, so reimplement... */ \
    JS_NORETURN JS_PRINTFLIKE(2,3) \
    U8J_API void c_js_ ## name_err(js_State *J, const char *fmt, ...) { \
        va_list ap; \
        char buf[256];  /* same size which mujs itself uses internally */ \
        va_start(ap, fmt); \
        vsnprintf(buf, sizeof buf, fmt, ap); \
        va_end(ap); \
        js_new ## name_err(J, buf); \
        js_throw(J); \
    } \
    JS_NORETURN JS_PRINTFLIKE(2,3) \
    U8J_API void u_js_ ## name_err(js_State *J, const char *fmt, ...) { \
        va_list ap; \
        char buf[256]; \
        va_start(ap, fmt); \
        vsnprintf(buf, sizeof buf, fmt, ap); \
        va_end(ap); \
        u_js_new ## name_err(J, buf); \
        js_throw(J); \
    }

U8J__DERROR(error)
U8J__DERROR(evalerror)
U8J__DERROR(rangeerror)
U8J__DERROR(referenceerror)
U8J__DERROR(syntaxerror)
U8J__DERROR(typeerror)
U8J__DERROR(urierror)

#undef U8J__DERROR


/***********************************************
 * Wrappers for mujs APIs which return strings *
 ***********************************************/

/*
 * The main challenge here is where to store the return value such that it
 * remains available to the caller as long as the original CESU-8 value would
 * (i.e. if a conversion is required to begin with).
 *
 * Our general tool is to keep the UTF-8 string at the VM so that it can be
 * garbage-collected normally.
 *
 * There are only 5 APIs which return a string which may need conversion:
 * - js_tostring, js_torepr, js_trystring, js_tryrepr, js_nextiterator.
 *
 * js_tostring and js_torepr replace a value at the stack with the (CESU-8)
 * string, and we simply replace it again with a userdata object which holds
 * the UTF-8 string and return it. The pointer remains valid as long as the
 * userdata object is at the stack (or referenced in general), and otherwise
 * garbage-collected and finalized (freed).
 *
 * js_trystring and js_tryrepr are similar, except they also take a sentinel
 * error string which, on error, we must return (the pointer) as is and without
 * any conversion, so we can't blindly convert the result. These are therefore
 * simple try/catch wrappers around u_js_try{string,repr}.
 *
 * js_nextierator does not have an associated stack string value which we can
 * replace, so we store the UTF-8 string as a userdata property of the iterator
 * itself, which gets garbage collected after we replace it with the next one
 * or when the iterator is garbage-collected.
 */


U8J_API const char *c_js_torepr(js_State *J, int idx) { return js_torepr(J, idx); } \
U8J_API const char *u_js_torepr(js_State *J, int idx) {
	js_repr(J, idx);
	js_replace(J, idx < 0 ? idx-1 : idx);
	return u_js_tostring(J, idx);
}

#define U8J__OUT_TRY(name) \
    U8J_API const char *c_js_try ## name(js_State *J, int idx, const char *error) { return js_try ## name(J, idx, error); } \
    U8J_API const char *u_js_try ## name(js_State *J, int idx, const char *error) { \
        const char *s; \
        if (js_try(J)) { \
            js_pop(J, 1);  /* the JS error value */ \
            return error; \
        } \
        s = u_js_to ## name(J, idx); \
        js_endtry(J); \
        return s; \
    }

U8J__OUT_TRY(string)
U8J__OUT_TRY(repr)


/* js_nextiterator - store the userdata as "u8j_ret" property of the iterator */
U8J_API const char * c_js_nextiterator(js_State *J, int idx) { return js_nextiterator(J, idx); }
U8J_API const char * u_js_nextiterator(js_State *J, int idx) {
    const char *str = js_nextiterator(J, idx);
    int utf8_len = u8j_utf8_len(str);
    if (utf8_len == 0)
        return str;

    str = u8j__push_utf8ret(J, str, utf8_len);
    js_setproperty(J, idx < 0 ? idx - 1 : idx, "u8j_ret");
    return str;
}



#define js_dostring u_js_dostring
#define js_loadstring u_js_loadstring
#define js_ploadstring u_js_ploadstring

#define js_getglobal u_js_getglobal
#define js_setglobal u_js_setglobal
#define js_defglobal u_js_defglobal
#define js_delglobal u_js_delglobal

#define js_hasproperty u_js_hasproperty
#define js_getproperty u_js_getproperty
#define js_setproperty u_js_setproperty
#define js_defproperty u_js_defproperty
#define js_delproperty u_js_delproperty
#define js_defaccessor u_js_defaccessor

#define js_newcfunction u_js_newcfunction
#define js_newcconstructor u_js_newcconstructor
#define js_newregexp u_js_newregexp
#define js_newstring u_js_newstring

#define js_pushlstring u_js_pushlstring
#define js_pushstring u_js_pushstring
#define js_pushliteral u_js_pushliteral

#define js_error u_js_error
#define js_evalerror u_js_evalerror
#define js_rangeerror u_js_rangeerror
#define js_referenceerror u_js_referenceerror
#define js_syntaxerror u_js_syntaxerror
#define js_typeerror u_js_typeerror
#define js_urierror u_js_urierror

#define js_newnewerror u_js_newerror
#define js_newevalerror u_js_newevalerror
#define js_newrangeerror u_js_newrangeerror
#define js_newreferenceerror u_js_newreferenceerror
#define js_newsyntaxerror u_js_newsyntaxerror
#define js_newtypeerror u_js_newtypeerror
#define js_newurierror u_js_newurierror

#define js_tostring u_js_tostring
#define js_trystring u_js_trystring
#define js_torepr u_js_torepr
#define js_tryrepr u_js_tryrepr

#define js_nextiterator u_js_nextiterator
